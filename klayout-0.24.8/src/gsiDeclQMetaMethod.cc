
/*

  KLayout Layout Viewer
  Copyright (C) 2006-2016 Matthias Koefferlein

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

*/

/**
*  @file gsiDeclQMetaMethod.cc 
*
*  DO NOT EDIT THIS FILE. 
*  This file has been created automatically
*/

#include "gsiQtCore.h"
#include "gsiDeclQtTypeTraits.h"
#include "gsiDeclQMetaMethod_Enums.h"
#include <memory>

// -----------------------------------------------------------------------
// class QMetaMethod

//  Constructor QMetaMethod::QMetaMethod()


static void _init_ctor_QMetaMethod_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return_new<QMetaMethod *> ();
}

static void _call_ctor_QMetaMethod_0 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<QMetaMethod *> (new QMetaMethod ());
}

static qt_gsi::GenericStaticMethod *_create_ctor_QMetaMethod_0 ()
{
  return new qt_gsi::GenericStaticMethod ("new", "@brief Constructor QMetaMethod::QMetaMethod()\nThis method creates an object of class QMetaMethod.", &_init_ctor_QMetaMethod_0, &_call_ctor_QMetaMethod_0);
}

// QMetaMethod::Access QMetaMethod::access()


static void _init_f_access_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QMetaMethod::Access>::target_type > ();
}

static void _call_f_access_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QMetaMethod::Access>::target_type > ((qt_gsi::Converter<QMetaMethod::Access>::target_type)qt_gsi::CppToQtAdaptor<QMetaMethod::Access>(((QMetaMethod *)cls)->access ()));
}

static qt_gsi::GenericMethod *_create_f_access_c0 ()
{
  return new qt_gsi::GenericMethod ("access", "@brief Method QMetaMethod::Access QMetaMethod::access()\n", true, &_init_f_access_c0, &_call_f_access_c0);
}

// int QMetaMethod::attributes()


static void _init_f_attributes_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<int > ();
}

static void _call_f_attributes_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<int > ((int)((QMetaMethod *)cls)->attributes ());
}

static qt_gsi::GenericMethod *_create_f_attributes_c0 ()
{
  return new qt_gsi::GenericMethod ("attributes", "@brief Method int QMetaMethod::attributes()\n", true, &_init_f_attributes_c0, &_call_f_attributes_c0);
}

// const QMetaObject *QMetaMethod::enclosingMetaObject()


static void _init_f_enclosingMetaObject_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<const QMetaObject * > ();
}

static void _call_f_enclosingMetaObject_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<const QMetaObject * > ((const QMetaObject *)((QMetaMethod *)cls)->enclosingMetaObject ());
}

static qt_gsi::GenericMethod *_create_f_enclosingMetaObject_c0 ()
{
  return new qt_gsi::GenericMethod ("enclosingMetaObject", "@brief Method const QMetaObject *QMetaMethod::enclosingMetaObject()\n", true, &_init_f_enclosingMetaObject_c0, &_call_f_enclosingMetaObject_c0);
}

// int QMetaMethod::methodIndex()


static void _init_f_methodIndex_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<int > ();
}

static void _call_f_methodIndex_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<int > ((int)((QMetaMethod *)cls)->methodIndex ());
}

static qt_gsi::GenericMethod *_create_f_methodIndex_c0 ()
{
  return new qt_gsi::GenericMethod ("methodIndex", "@brief Method int QMetaMethod::methodIndex()\n", true, &_init_f_methodIndex_c0, &_call_f_methodIndex_c0);
}

// QMetaMethod::MethodType QMetaMethod::methodType()


static void _init_f_methodType_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QMetaMethod::MethodType>::target_type > ();
}

static void _call_f_methodType_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QMetaMethod::MethodType>::target_type > ((qt_gsi::Converter<QMetaMethod::MethodType>::target_type)qt_gsi::CppToQtAdaptor<QMetaMethod::MethodType>(((QMetaMethod *)cls)->methodType ()));
}

static qt_gsi::GenericMethod *_create_f_methodType_c0 ()
{
  return new qt_gsi::GenericMethod ("methodType", "@brief Method QMetaMethod::MethodType QMetaMethod::methodType()\n", true, &_init_f_methodType_c0, &_call_f_methodType_c0);
}

// QList<QByteArray> QMetaMethod::parameterNames()


static void _init_f_parameterNames_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QList<QByteArray> >::target_type > ();
}

static void _call_f_parameterNames_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QList<QByteArray> >::target_type > ((qt_gsi::Converter<QList<QByteArray> >::target_type)qt_gsi::CppToQtAdaptor<QList<QByteArray> >(((QMetaMethod *)cls)->parameterNames ()));
}

static qt_gsi::GenericMethod *_create_f_parameterNames_c0 ()
{
  return new qt_gsi::GenericMethod ("parameterNames", "@brief Method QList<QByteArray> QMetaMethod::parameterNames()\n", true, &_init_f_parameterNames_c0, &_call_f_parameterNames_c0);
}

// QList<QByteArray> QMetaMethod::parameterTypes()


static void _init_f_parameterTypes_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QList<QByteArray> >::target_type > ();
}

static void _call_f_parameterTypes_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QList<QByteArray> >::target_type > ((qt_gsi::Converter<QList<QByteArray> >::target_type)qt_gsi::CppToQtAdaptor<QList<QByteArray> >(((QMetaMethod *)cls)->parameterTypes ()));
}

static qt_gsi::GenericMethod *_create_f_parameterTypes_c0 ()
{
  return new qt_gsi::GenericMethod ("parameterTypes", "@brief Method QList<QByteArray> QMetaMethod::parameterTypes()\n", true, &_init_f_parameterTypes_c0, &_call_f_parameterTypes_c0);
}

// const char *QMetaMethod::signature()


static void _init_f_signature_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<const char * > ();
}

static void _call_f_signature_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<const char * > ((const char *)((QMetaMethod *)cls)->signature ());
}

static qt_gsi::GenericMethod *_create_f_signature_c0 ()
{
  return new qt_gsi::GenericMethod ("signature", "@brief Method const char *QMetaMethod::signature()\n", true, &_init_f_signature_c0, &_call_f_signature_c0);
}

// const char *QMetaMethod::tag()


static void _init_f_tag_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<const char * > ();
}

static void _call_f_tag_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<const char * > ((const char *)((QMetaMethod *)cls)->tag ());
}

static qt_gsi::GenericMethod *_create_f_tag_c0 ()
{
  return new qt_gsi::GenericMethod ("tag", "@brief Method const char *QMetaMethod::tag()\n", true, &_init_f_tag_c0, &_call_f_tag_c0);
}

// const char *QMetaMethod::typeName()


static void _init_f_typeName_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<const char * > ();
}

static void _call_f_typeName_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<const char * > ((const char *)((QMetaMethod *)cls)->typeName ());
}

static qt_gsi::GenericMethod *_create_f_typeName_c0 ()
{
  return new qt_gsi::GenericMethod ("typeName", "@brief Method const char *QMetaMethod::typeName()\n", true, &_init_f_typeName_c0, &_call_f_typeName_c0);
}


namespace gsi
{
gsi::Class<QMetaMethod> decl_QMetaMethod ("QMetaMethod",
  gsi::Methods(_create_ctor_QMetaMethod_0 ()) +
  gsi::Methods(_create_f_access_c0 ()) +
  gsi::Methods(_create_f_attributes_c0 ()) +
  gsi::Methods(_create_f_enclosingMetaObject_c0 ()) +
  gsi::Methods(_create_f_methodIndex_c0 ()) +
  gsi::Methods(_create_f_methodType_c0 ()) +
  gsi::Methods(_create_f_parameterNames_c0 ()) +
  gsi::Methods(_create_f_parameterTypes_c0 ()) +
  gsi::Methods(_create_f_signature_c0 ()) +
  gsi::Methods(_create_f_tag_c0 ()) +
  gsi::Methods(_create_f_typeName_c0 ()),
  "@qt\n@brief Binding of QMetaMethod");

}


//  Implementation of the enum wrapper class for QMetaMethod::Access
namespace qt_gsi
{

static QMetaMethod_Access_Enum *c_1_QMetaMethod_Access_Enum () { return new QMetaMethod_Access_Enum (QMetaMethod::Private); }
static QMetaMethod_Access_Enum *c_2_QMetaMethod_Access_Enum () { return new QMetaMethod_Access_Enum (QMetaMethod::Protected); }
static QMetaMethod_Access_Enum *c_3_QMetaMethod_Access_Enum () { return new QMetaMethod_Access_Enum (QMetaMethod::Public); }

static gsi::Methods mkdefs_QMetaMethod_Access () {
  return
    gsi::constant ("Private", &qt_gsi::c_1_QMetaMethod_Access_Enum, "@brief Enum constant QMetaMethod::Private") +
    gsi::constant ("Protected", &qt_gsi::c_2_QMetaMethod_Access_Enum, "@brief Enum constant QMetaMethod::Protected") +
    gsi::constant ("Public", &qt_gsi::c_3_QMetaMethod_Access_Enum, "@brief Enum constant QMetaMethod::Public");
}

static std::string to_s_QMetaMethod_Access_Enum (const QMetaMethod_Access_Enum *e)
{
  if (e->value () == QMetaMethod::Private) { return tl::sprintf ("Private (%u)", (unsigned int) e->value ()); }
  if (e->value () == QMetaMethod::Protected) { return tl::sprintf ("Protected (%u)", (unsigned int) e->value ()); }
  if (e->value () == QMetaMethod::Public) { return tl::sprintf ("Public (%u)", (unsigned int) e->value ()); }
  return std::string ("(not a valid enum evalue)");
}

static unsigned int to_i_QMetaMethod_Access_Enum (const QMetaMethod_Access_Enum *e)
{
  return (unsigned int) e->value ();
}

static QMetaMethod_Access_Enum *from_i_QMetaMethod_Access_Enum (unsigned int i)
{
  return new QMetaMethod_Access_Enum ((QMetaMethod::Access) i);
}

static bool equalQMetaMethod_Access_Enum (const QMetaMethod_Access_Enum *e, QMetaMethod_Access_Enum d)
{
  return e->value () == d.value ();
}

static bool equal2QMetaMethod_Access_Enum (const QMetaMethod_Access_Enum *e, unsigned int i)
{
  return (unsigned int) e->value () == i;
}

static QMetaMethod_Access_Enums oropQMetaMethod_Access_Enums (const QMetaMethod_Access_Enums *e, const QMetaMethod_Access_Enums &d)
{
  return e->flags () | d.flags ();
}

static QMetaMethod_Access_Enums andopQMetaMethod_Access_Enums (const QMetaMethod_Access_Enums *e, const QMetaMethod_Access_Enums &d)
{
  return e->flags () & d.flags ();
}

static QMetaMethod_Access_Enums xoropQMetaMethod_Access_Enums (const QMetaMethod_Access_Enums *e, const QMetaMethod_Access_Enums &d)
{
  return e->flags () ^ d.flags ();
}

static std::string to_s_QMetaMethod_Access_Enums (const QMetaMethod_Access_Enums *e)
{
  std::string l;
  if (e->testFlag (QMetaMethod::Private)) { if (!l.empty ()) l += "|"; l += "Private"; }
  if (e->testFlag (QMetaMethod::Protected)) { if (!l.empty ()) l += "|"; l += "Protected"; }
  if (e->testFlag (QMetaMethod::Public)) { if (!l.empty ()) l += "|"; l += "Public"; }
  return tl::sprintf ("%u (%s)", (unsigned int) (e->flags ()), l);
}

static int to_i_QMetaMethod_Access_Enums (const QMetaMethod_Access_Enums *e)
{
  return int (e->flags ());
}

static bool testFlag_QMetaMethod_Access_Enums (const QMetaMethod_Access_Enums *e, const QMetaMethod_Access_Enum &d)
{
  return e->flags ().testFlag (d.value ());
}

}

namespace gsi
{

//  Declarations for QFlags<enum> wrapper class
gsi::Class<qt_gsi::QMetaMethod_Access_Enums> decl_QMetaMethod_Access_Enums ("QMetaMethod_QFlags_Access",
  gsi::method_ext ("|", &qt_gsi::oropQMetaMethod_Access_Enums, gsi::arg ("other"), "@brief 'or' operator between two flag sets") +
  gsi::method_ext ("&", &qt_gsi::andopQMetaMethod_Access_Enums, gsi::arg ("other"), "@brief 'and' operator between two flag sets") +
  gsi::method_ext ("^", &qt_gsi::xoropQMetaMethod_Access_Enums, gsi::arg ("other"), "@brief 'xor' operator between two flag sets") +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QMetaMethod_Access_Enums, "@brief Converts the flag set to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QMetaMethod_Access_Enums, "@brief Returns the integer value encoding the flag set") +
  gsi::method_ext ("testFlag", &qt_gsi::testFlag_QMetaMethod_Access_Enums, gsi::arg ("flag"), "@brief Tests whether the flag is contained in the flag set"),
  "@qt\n@brief This class represents the QFlags<QMetaMethod::Access> flag set");

//  Declarations for enum wrapper class
gsi::Class<qt_gsi::QMetaMethod_Access_Enum> decl_QMetaMethod_Access_Enum (decl_QMetaMethod_Access_Enums, "QMetaMethod_Access",
  qt_gsi::mkdefs_QMetaMethod_Access () +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QMetaMethod_Access_Enum, "@brief Converts the enum class to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QMetaMethod_Access_Enum, "@brief Converts the enum class to an integer") +
  gsi::method_ext ("==", &qt_gsi::equalQMetaMethod_Access_Enum, gsi::arg ("other"), "@brief Compares the enum class against an enum of it's own type") +
  gsi::method_ext ("==", &qt_gsi::equal2QMetaMethod_Access_Enum, gsi::arg ("other"), "@brief Compares the enum class against an integer") +
  gsi::constructor ("new", &qt_gsi::from_i_QMetaMethod_Access_Enum, gsi::arg ("value"), "@brief Creates the enum object from an integer"),
  "@qt\n@brief This class represents the QMetaMethod::Access enum");

//  Inject the declarations into the parent
static gsi::ClassExt<QMetaMethod> inject_QMetaMethod_Access_Enum_in_parent (qt_gsi::mkdefs_QMetaMethod_Access ());
static gsi::ClassExt<QMetaMethod> decl_QMetaMethod_Access_Enum_as_child (decl_QMetaMethod_Access_Enum, "Access");

}


//  Implementation of the enum wrapper class for QMetaMethod::MethodType
namespace qt_gsi
{

static QMetaMethod_MethodType_Enum *c_1_QMetaMethod_MethodType_Enum () { return new QMetaMethod_MethodType_Enum (QMetaMethod::Method); }
static QMetaMethod_MethodType_Enum *c_2_QMetaMethod_MethodType_Enum () { return new QMetaMethod_MethodType_Enum (QMetaMethod::Signal); }
static QMetaMethod_MethodType_Enum *c_3_QMetaMethod_MethodType_Enum () { return new QMetaMethod_MethodType_Enum (QMetaMethod::Slot); }
static QMetaMethod_MethodType_Enum *c_4_QMetaMethod_MethodType_Enum () { return new QMetaMethod_MethodType_Enum (QMetaMethod::Constructor); }

static gsi::Methods mkdefs_QMetaMethod_MethodType () {
  return
    gsi::constant ("Method", &qt_gsi::c_1_QMetaMethod_MethodType_Enum, "@brief Enum constant QMetaMethod::Method") +
    gsi::constant ("Signal", &qt_gsi::c_2_QMetaMethod_MethodType_Enum, "@brief Enum constant QMetaMethod::Signal") +
    gsi::constant ("Slot", &qt_gsi::c_3_QMetaMethod_MethodType_Enum, "@brief Enum constant QMetaMethod::Slot") +
    gsi::constant ("Constructor", &qt_gsi::c_4_QMetaMethod_MethodType_Enum, "@brief Enum constant QMetaMethod::Constructor");
}

static std::string to_s_QMetaMethod_MethodType_Enum (const QMetaMethod_MethodType_Enum *e)
{
  if (e->value () == QMetaMethod::Method) { return tl::sprintf ("Method (%u)", (unsigned int) e->value ()); }
  if (e->value () == QMetaMethod::Signal) { return tl::sprintf ("Signal (%u)", (unsigned int) e->value ()); }
  if (e->value () == QMetaMethod::Slot) { return tl::sprintf ("Slot (%u)", (unsigned int) e->value ()); }
  if (e->value () == QMetaMethod::Constructor) { return tl::sprintf ("Constructor (%u)", (unsigned int) e->value ()); }
  return std::string ("(not a valid enum evalue)");
}

static unsigned int to_i_QMetaMethod_MethodType_Enum (const QMetaMethod_MethodType_Enum *e)
{
  return (unsigned int) e->value ();
}

static QMetaMethod_MethodType_Enum *from_i_QMetaMethod_MethodType_Enum (unsigned int i)
{
  return new QMetaMethod_MethodType_Enum ((QMetaMethod::MethodType) i);
}

static bool equalQMetaMethod_MethodType_Enum (const QMetaMethod_MethodType_Enum *e, QMetaMethod_MethodType_Enum d)
{
  return e->value () == d.value ();
}

static bool equal2QMetaMethod_MethodType_Enum (const QMetaMethod_MethodType_Enum *e, unsigned int i)
{
  return (unsigned int) e->value () == i;
}

static QMetaMethod_MethodType_Enums oropQMetaMethod_MethodType_Enums (const QMetaMethod_MethodType_Enums *e, const QMetaMethod_MethodType_Enums &d)
{
  return e->flags () | d.flags ();
}

static QMetaMethod_MethodType_Enums andopQMetaMethod_MethodType_Enums (const QMetaMethod_MethodType_Enums *e, const QMetaMethod_MethodType_Enums &d)
{
  return e->flags () & d.flags ();
}

static QMetaMethod_MethodType_Enums xoropQMetaMethod_MethodType_Enums (const QMetaMethod_MethodType_Enums *e, const QMetaMethod_MethodType_Enums &d)
{
  return e->flags () ^ d.flags ();
}

static std::string to_s_QMetaMethod_MethodType_Enums (const QMetaMethod_MethodType_Enums *e)
{
  std::string l;
  if (e->testFlag (QMetaMethod::Method)) { if (!l.empty ()) l += "|"; l += "Method"; }
  if (e->testFlag (QMetaMethod::Signal)) { if (!l.empty ()) l += "|"; l += "Signal"; }
  if (e->testFlag (QMetaMethod::Slot)) { if (!l.empty ()) l += "|"; l += "Slot"; }
  if (e->testFlag (QMetaMethod::Constructor)) { if (!l.empty ()) l += "|"; l += "Constructor"; }
  return tl::sprintf ("%u (%s)", (unsigned int) (e->flags ()), l);
}

static int to_i_QMetaMethod_MethodType_Enums (const QMetaMethod_MethodType_Enums *e)
{
  return int (e->flags ());
}

static bool testFlag_QMetaMethod_MethodType_Enums (const QMetaMethod_MethodType_Enums *e, const QMetaMethod_MethodType_Enum &d)
{
  return e->flags ().testFlag (d.value ());
}

}

namespace gsi
{

//  Declarations for QFlags<enum> wrapper class
gsi::Class<qt_gsi::QMetaMethod_MethodType_Enums> decl_QMetaMethod_MethodType_Enums ("QMetaMethod_QFlags_MethodType",
  gsi::method_ext ("|", &qt_gsi::oropQMetaMethod_MethodType_Enums, gsi::arg ("other"), "@brief 'or' operator between two flag sets") +
  gsi::method_ext ("&", &qt_gsi::andopQMetaMethod_MethodType_Enums, gsi::arg ("other"), "@brief 'and' operator between two flag sets") +
  gsi::method_ext ("^", &qt_gsi::xoropQMetaMethod_MethodType_Enums, gsi::arg ("other"), "@brief 'xor' operator between two flag sets") +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QMetaMethod_MethodType_Enums, "@brief Converts the flag set to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QMetaMethod_MethodType_Enums, "@brief Returns the integer value encoding the flag set") +
  gsi::method_ext ("testFlag", &qt_gsi::testFlag_QMetaMethod_MethodType_Enums, gsi::arg ("flag"), "@brief Tests whether the flag is contained in the flag set"),
  "@qt\n@brief This class represents the QFlags<QMetaMethod::MethodType> flag set");

//  Declarations for enum wrapper class
gsi::Class<qt_gsi::QMetaMethod_MethodType_Enum> decl_QMetaMethod_MethodType_Enum (decl_QMetaMethod_MethodType_Enums, "QMetaMethod_MethodType",
  qt_gsi::mkdefs_QMetaMethod_MethodType () +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QMetaMethod_MethodType_Enum, "@brief Converts the enum class to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QMetaMethod_MethodType_Enum, "@brief Converts the enum class to an integer") +
  gsi::method_ext ("==", &qt_gsi::equalQMetaMethod_MethodType_Enum, gsi::arg ("other"), "@brief Compares the enum class against an enum of it's own type") +
  gsi::method_ext ("==", &qt_gsi::equal2QMetaMethod_MethodType_Enum, gsi::arg ("other"), "@brief Compares the enum class against an integer") +
  gsi::constructor ("new", &qt_gsi::from_i_QMetaMethod_MethodType_Enum, gsi::arg ("value"), "@brief Creates the enum object from an integer"),
  "@qt\n@brief This class represents the QMetaMethod::MethodType enum");

//  Inject the declarations into the parent
static gsi::ClassExt<QMetaMethod> inject_QMetaMethod_MethodType_Enum_in_parent (qt_gsi::mkdefs_QMetaMethod_MethodType ());
static gsi::ClassExt<QMetaMethod> decl_QMetaMethod_MethodType_Enum_as_child (decl_QMetaMethod_MethodType_Enum, "MethodType");

}

