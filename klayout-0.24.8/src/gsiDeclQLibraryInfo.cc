
/*

  KLayout Layout Viewer
  Copyright (C) 2006-2016 Matthias Koefferlein

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

*/

/**
*  @file gsiDeclQLibraryInfo.cc 
*
*  DO NOT EDIT THIS FILE. 
*  This file has been created automatically
*/

#include "gsiQtCore.h"
#include "gsiDeclQtTypeTraits.h"
#include "gsiDeclQLibraryInfo_Enums.h"
#include <memory>

// -----------------------------------------------------------------------
// class QLibraryInfo

// static QDate QLibraryInfo::buildDate()


static void _init_f_buildDate_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QDate > ();
}

static void _call_f_buildDate_0 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<QDate > ((QDate)QLibraryInfo::buildDate ());
}

static qt_gsi::GenericStaticMethod *_create_f_buildDate_0 ()
{
  return new qt_gsi::GenericStaticMethod ("buildDate", "@brief Static method QDate QLibraryInfo::buildDate()\nThis method is static and can be called without an instance.", &_init_f_buildDate_0, &_call_f_buildDate_0);
}

// static QString QLibraryInfo::buildKey()


static void _init_f_buildKey_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_buildKey_0 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<QString > ((QString)QLibraryInfo::buildKey ());
}

static qt_gsi::GenericStaticMethod *_create_f_buildKey_0 ()
{
  return new qt_gsi::GenericStaticMethod ("buildKey", "@brief Static method QString QLibraryInfo::buildKey()\nThis method is static and can be called without an instance.", &_init_f_buildKey_0, &_call_f_buildKey_0);
}

// static QString QLibraryInfo::licensedProducts()


static void _init_f_licensedProducts_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_licensedProducts_0 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<QString > ((QString)QLibraryInfo::licensedProducts ());
}

static qt_gsi::GenericStaticMethod *_create_f_licensedProducts_0 ()
{
  return new qt_gsi::GenericStaticMethod ("licensedProducts", "@brief Static method QString QLibraryInfo::licensedProducts()\nThis method is static and can be called without an instance.", &_init_f_licensedProducts_0, &_call_f_licensedProducts_0);
}

// static QString QLibraryInfo::licensee()


static void _init_f_licensee_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return<QString > ();
}

static void _call_f_licensee_0 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<QString > ((QString)QLibraryInfo::licensee ());
}

static qt_gsi::GenericStaticMethod *_create_f_licensee_0 ()
{
  return new qt_gsi::GenericStaticMethod ("licensee", "@brief Static method QString QLibraryInfo::licensee()\nThis method is static and can be called without an instance.", &_init_f_licensee_0, &_call_f_licensee_0);
}

// static QString QLibraryInfo::location(QLibraryInfo::LibraryLocation)


static void _init_f_location_3304 (qt_gsi::GenericStaticMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("arg1");
  decl->add_arg<const qt_gsi::Converter<QLibraryInfo::LibraryLocation>::target_type & > (argspec_0);
  decl->set_return<QString > ();
}

static void _call_f_location_3304 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QLibraryInfo::LibraryLocation>::target_type & arg1 = args.read<const qt_gsi::Converter<QLibraryInfo::LibraryLocation>::target_type & > ();
  ret.write<QString > ((QString)QLibraryInfo::location (qt_gsi::QtToCppAdaptor<QLibraryInfo::LibraryLocation>(arg1).cref()));
}

static qt_gsi::GenericStaticMethod *_create_f_location_3304 ()
{
  return new qt_gsi::GenericStaticMethod ("location", "@brief Static method QString QLibraryInfo::location(QLibraryInfo::LibraryLocation)\nThis method is static and can be called without an instance.", &_init_f_location_3304, &_call_f_location_3304);
}


namespace gsi
{
gsi::Class<QLibraryInfo> decl_QLibraryInfo ("QLibraryInfo",
  gsi::Methods(_create_f_buildDate_0 ()) +
  gsi::Methods(_create_f_buildKey_0 ()) +
  gsi::Methods(_create_f_licensedProducts_0 ()) +
  gsi::Methods(_create_f_licensee_0 ()) +
  gsi::Methods(_create_f_location_3304 ()),
  "@qt\n@brief Binding of QLibraryInfo");

}


//  Implementation of the enum wrapper class for QLibraryInfo::LibraryLocation
namespace qt_gsi
{

static QLibraryInfo_LibraryLocation_Enum *c_1_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::PrefixPath); }
static QLibraryInfo_LibraryLocation_Enum *c_2_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::DocumentationPath); }
static QLibraryInfo_LibraryLocation_Enum *c_3_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::HeadersPath); }
static QLibraryInfo_LibraryLocation_Enum *c_4_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::LibrariesPath); }
static QLibraryInfo_LibraryLocation_Enum *c_5_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::BinariesPath); }
static QLibraryInfo_LibraryLocation_Enum *c_6_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::PluginsPath); }
static QLibraryInfo_LibraryLocation_Enum *c_7_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::DataPath); }
static QLibraryInfo_LibraryLocation_Enum *c_8_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::TranslationsPath); }
static QLibraryInfo_LibraryLocation_Enum *c_9_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::SettingsPath); }
static QLibraryInfo_LibraryLocation_Enum *c_10_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::DemosPath); }
static QLibraryInfo_LibraryLocation_Enum *c_11_QLibraryInfo_LibraryLocation_Enum () { return new QLibraryInfo_LibraryLocation_Enum (QLibraryInfo::ExamplesPath); }

static gsi::Methods mkdefs_QLibraryInfo_LibraryLocation () {
  return
    gsi::constant ("PrefixPath", &qt_gsi::c_1_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::PrefixPath") +
    gsi::constant ("DocumentationPath", &qt_gsi::c_2_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::DocumentationPath") +
    gsi::constant ("HeadersPath", &qt_gsi::c_3_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::HeadersPath") +
    gsi::constant ("LibrariesPath", &qt_gsi::c_4_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::LibrariesPath") +
    gsi::constant ("BinariesPath", &qt_gsi::c_5_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::BinariesPath") +
    gsi::constant ("PluginsPath", &qt_gsi::c_6_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::PluginsPath") +
    gsi::constant ("DataPath", &qt_gsi::c_7_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::DataPath") +
    gsi::constant ("TranslationsPath", &qt_gsi::c_8_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::TranslationsPath") +
    gsi::constant ("SettingsPath", &qt_gsi::c_9_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::SettingsPath") +
    gsi::constant ("DemosPath", &qt_gsi::c_10_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::DemosPath") +
    gsi::constant ("ExamplesPath", &qt_gsi::c_11_QLibraryInfo_LibraryLocation_Enum, "@brief Enum constant QLibraryInfo::ExamplesPath");
}

static std::string to_s_QLibraryInfo_LibraryLocation_Enum (const QLibraryInfo_LibraryLocation_Enum *e)
{
  if (e->value () == QLibraryInfo::PrefixPath) { return tl::sprintf ("PrefixPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::DocumentationPath) { return tl::sprintf ("DocumentationPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::HeadersPath) { return tl::sprintf ("HeadersPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::LibrariesPath) { return tl::sprintf ("LibrariesPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::BinariesPath) { return tl::sprintf ("BinariesPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::PluginsPath) { return tl::sprintf ("PluginsPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::DataPath) { return tl::sprintf ("DataPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::TranslationsPath) { return tl::sprintf ("TranslationsPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::SettingsPath) { return tl::sprintf ("SettingsPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::DemosPath) { return tl::sprintf ("DemosPath (%u)", (unsigned int) e->value ()); }
  if (e->value () == QLibraryInfo::ExamplesPath) { return tl::sprintf ("ExamplesPath (%u)", (unsigned int) e->value ()); }
  return std::string ("(not a valid enum evalue)");
}

static unsigned int to_i_QLibraryInfo_LibraryLocation_Enum (const QLibraryInfo_LibraryLocation_Enum *e)
{
  return (unsigned int) e->value ();
}

static QLibraryInfo_LibraryLocation_Enum *from_i_QLibraryInfo_LibraryLocation_Enum (unsigned int i)
{
  return new QLibraryInfo_LibraryLocation_Enum ((QLibraryInfo::LibraryLocation) i);
}

static bool equalQLibraryInfo_LibraryLocation_Enum (const QLibraryInfo_LibraryLocation_Enum *e, QLibraryInfo_LibraryLocation_Enum d)
{
  return e->value () == d.value ();
}

static bool equal2QLibraryInfo_LibraryLocation_Enum (const QLibraryInfo_LibraryLocation_Enum *e, unsigned int i)
{
  return (unsigned int) e->value () == i;
}

static QLibraryInfo_LibraryLocation_Enums oropQLibraryInfo_LibraryLocation_Enums (const QLibraryInfo_LibraryLocation_Enums *e, const QLibraryInfo_LibraryLocation_Enums &d)
{
  return e->flags () | d.flags ();
}

static QLibraryInfo_LibraryLocation_Enums andopQLibraryInfo_LibraryLocation_Enums (const QLibraryInfo_LibraryLocation_Enums *e, const QLibraryInfo_LibraryLocation_Enums &d)
{
  return e->flags () & d.flags ();
}

static QLibraryInfo_LibraryLocation_Enums xoropQLibraryInfo_LibraryLocation_Enums (const QLibraryInfo_LibraryLocation_Enums *e, const QLibraryInfo_LibraryLocation_Enums &d)
{
  return e->flags () ^ d.flags ();
}

static std::string to_s_QLibraryInfo_LibraryLocation_Enums (const QLibraryInfo_LibraryLocation_Enums *e)
{
  std::string l;
  if (e->testFlag (QLibraryInfo::PrefixPath)) { if (!l.empty ()) l += "|"; l += "PrefixPath"; }
  if (e->testFlag (QLibraryInfo::DocumentationPath)) { if (!l.empty ()) l += "|"; l += "DocumentationPath"; }
  if (e->testFlag (QLibraryInfo::HeadersPath)) { if (!l.empty ()) l += "|"; l += "HeadersPath"; }
  if (e->testFlag (QLibraryInfo::LibrariesPath)) { if (!l.empty ()) l += "|"; l += "LibrariesPath"; }
  if (e->testFlag (QLibraryInfo::BinariesPath)) { if (!l.empty ()) l += "|"; l += "BinariesPath"; }
  if (e->testFlag (QLibraryInfo::PluginsPath)) { if (!l.empty ()) l += "|"; l += "PluginsPath"; }
  if (e->testFlag (QLibraryInfo::DataPath)) { if (!l.empty ()) l += "|"; l += "DataPath"; }
  if (e->testFlag (QLibraryInfo::TranslationsPath)) { if (!l.empty ()) l += "|"; l += "TranslationsPath"; }
  if (e->testFlag (QLibraryInfo::SettingsPath)) { if (!l.empty ()) l += "|"; l += "SettingsPath"; }
  if (e->testFlag (QLibraryInfo::DemosPath)) { if (!l.empty ()) l += "|"; l += "DemosPath"; }
  if (e->testFlag (QLibraryInfo::ExamplesPath)) { if (!l.empty ()) l += "|"; l += "ExamplesPath"; }
  return tl::sprintf ("%u (%s)", (unsigned int) (e->flags ()), l);
}

static int to_i_QLibraryInfo_LibraryLocation_Enums (const QLibraryInfo_LibraryLocation_Enums *e)
{
  return int (e->flags ());
}

static bool testFlag_QLibraryInfo_LibraryLocation_Enums (const QLibraryInfo_LibraryLocation_Enums *e, const QLibraryInfo_LibraryLocation_Enum &d)
{
  return e->flags ().testFlag (d.value ());
}

}

namespace gsi
{

//  Declarations for QFlags<enum> wrapper class
gsi::Class<qt_gsi::QLibraryInfo_LibraryLocation_Enums> decl_QLibraryInfo_LibraryLocation_Enums ("QLibraryInfo_QFlags_LibraryLocation",
  gsi::method_ext ("|", &qt_gsi::oropQLibraryInfo_LibraryLocation_Enums, gsi::arg ("other"), "@brief 'or' operator between two flag sets") +
  gsi::method_ext ("&", &qt_gsi::andopQLibraryInfo_LibraryLocation_Enums, gsi::arg ("other"), "@brief 'and' operator between two flag sets") +
  gsi::method_ext ("^", &qt_gsi::xoropQLibraryInfo_LibraryLocation_Enums, gsi::arg ("other"), "@brief 'xor' operator between two flag sets") +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QLibraryInfo_LibraryLocation_Enums, "@brief Converts the flag set to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QLibraryInfo_LibraryLocation_Enums, "@brief Returns the integer value encoding the flag set") +
  gsi::method_ext ("testFlag", &qt_gsi::testFlag_QLibraryInfo_LibraryLocation_Enums, gsi::arg ("flag"), "@brief Tests whether the flag is contained in the flag set"),
  "@qt\n@brief This class represents the QFlags<QLibraryInfo::LibraryLocation> flag set");

//  Declarations for enum wrapper class
gsi::Class<qt_gsi::QLibraryInfo_LibraryLocation_Enum> decl_QLibraryInfo_LibraryLocation_Enum (decl_QLibraryInfo_LibraryLocation_Enums, "QLibraryInfo_LibraryLocation",
  qt_gsi::mkdefs_QLibraryInfo_LibraryLocation () +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QLibraryInfo_LibraryLocation_Enum, "@brief Converts the enum class to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QLibraryInfo_LibraryLocation_Enum, "@brief Converts the enum class to an integer") +
  gsi::method_ext ("==", &qt_gsi::equalQLibraryInfo_LibraryLocation_Enum, gsi::arg ("other"), "@brief Compares the enum class against an enum of it's own type") +
  gsi::method_ext ("==", &qt_gsi::equal2QLibraryInfo_LibraryLocation_Enum, gsi::arg ("other"), "@brief Compares the enum class against an integer") +
  gsi::constructor ("new", &qt_gsi::from_i_QLibraryInfo_LibraryLocation_Enum, gsi::arg ("value"), "@brief Creates the enum object from an integer"),
  "@qt\n@brief This class represents the QLibraryInfo::LibraryLocation enum");

//  Inject the declarations into the parent
static gsi::ClassExt<QLibraryInfo> inject_QLibraryInfo_LibraryLocation_Enum_in_parent (qt_gsi::mkdefs_QLibraryInfo_LibraryLocation ());
static gsi::ClassExt<QLibraryInfo> decl_QLibraryInfo_LibraryLocation_Enum_as_child (decl_QLibraryInfo_LibraryLocation_Enum, "LibraryLocation");

}

