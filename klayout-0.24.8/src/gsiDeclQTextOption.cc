
/*

  KLayout Layout Viewer
  Copyright (C) 2006-2016 Matthias Koefferlein

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

*/

/**
*  @file gsiDeclQTextOption.cc 
*
*  DO NOT EDIT THIS FILE. 
*  This file has been created automatically
*/

#include "gsiQtGui.h"
#include "gsiDeclQtTypeTraits.h"
#include "gsiDeclQTextOption_Enums.h"
#include <memory>

// -----------------------------------------------------------------------
// class QTextOption

//  Constructor QTextOption::QTextOption()


static void _init_ctor_QTextOption_0 (qt_gsi::GenericStaticMethod *decl)
{
  decl->set_return_new<QTextOption *> ();
}

static void _call_ctor_QTextOption_0 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<QTextOption *> (new QTextOption ());
}

static qt_gsi::GenericStaticMethod *_create_ctor_QTextOption_0 ()
{
  return new qt_gsi::GenericStaticMethod ("new", "@brief Constructor QTextOption::QTextOption()\nThis method creates an object of class QTextOption.", &_init_ctor_QTextOption_0, &_call_ctor_QTextOption_0);
}

//  Constructor QTextOption::QTextOption(QFlags<Qt::AlignmentFlag> alignment)


static void _init_ctor_QTextOption_2750 (qt_gsi::GenericStaticMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("alignment");
  decl->add_arg<const qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type & > (argspec_0);
  decl->set_return_new<QTextOption *> ();
}

static void _call_ctor_QTextOption_2750 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type & arg1 = args.read<const qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type & > ();
  ret.write<QTextOption *> (new QTextOption (qt_gsi::QtToCppAdaptor<QFlags<Qt::AlignmentFlag> >(arg1).cref()));
}

static qt_gsi::GenericStaticMethod *_create_ctor_QTextOption_2750 ()
{
  return new qt_gsi::GenericStaticMethod ("new", "@brief Constructor QTextOption::QTextOption(QFlags<Qt::AlignmentFlag> alignment)\nThis method creates an object of class QTextOption.", &_init_ctor_QTextOption_2750, &_call_ctor_QTextOption_2750);
}

//  Constructor QTextOption::QTextOption(const QTextOption &o)


static void _init_ctor_QTextOption_2448 (qt_gsi::GenericStaticMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("o");
  decl->add_arg<const QTextOption & > (argspec_0);
  decl->set_return_new<QTextOption *> ();
}

static void _call_ctor_QTextOption_2448 (const qt_gsi::GenericStaticMethod *decl, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const QTextOption &arg1 = args.read<const QTextOption & > ();
  ret.write<QTextOption *> (new QTextOption (arg1));
}

static qt_gsi::GenericStaticMethod *_create_ctor_QTextOption_2448 ()
{
  return new qt_gsi::GenericStaticMethod ("new", "@brief Constructor QTextOption::QTextOption(const QTextOption &o)\nThis method creates an object of class QTextOption.", &_init_ctor_QTextOption_2448, &_call_ctor_QTextOption_2448);
}

// QFlags<Qt::AlignmentFlag> QTextOption::alignment()


static void _init_f_alignment_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type > ();
}

static void _call_f_alignment_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type > ((qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type)qt_gsi::CppToQtAdaptor<QFlags<Qt::AlignmentFlag> >(((QTextOption *)cls)->alignment ()));
}

static qt_gsi::GenericMethod *_create_f_alignment_c0 ()
{
  return new qt_gsi::GenericMethod (":alignment", "@brief Method QFlags<Qt::AlignmentFlag> QTextOption::alignment()\n", true, &_init_f_alignment_c0, &_call_f_alignment_c0);
}

// QFlags<QTextOption::Flag> QTextOption::flags()


static void _init_f_flags_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QFlags<QTextOption::Flag> >::target_type > ();
}

static void _call_f_flags_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QFlags<QTextOption::Flag> >::target_type > ((qt_gsi::Converter<QFlags<QTextOption::Flag> >::target_type)qt_gsi::CppToQtAdaptor<QFlags<QTextOption::Flag> >(((QTextOption *)cls)->flags ()));
}

static qt_gsi::GenericMethod *_create_f_flags_c0 ()
{
  return new qt_gsi::GenericMethod (":flags", "@brief Method QFlags<QTextOption::Flag> QTextOption::flags()\n", true, &_init_f_flags_c0, &_call_f_flags_c0);
}

// QTextOption &QTextOption::operator=(const QTextOption &o)


static void _init_f_operator_eq__2448 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("o");
  decl->add_arg<const QTextOption & > (argspec_0);
  decl->set_return<QTextOption & > ();
}

static void _call_f_operator_eq__2448 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const QTextOption &arg1 = args.read<const QTextOption & > ();
  ret.write<QTextOption & > ((QTextOption &)((QTextOption *)cls)->operator= (arg1));
}

static qt_gsi::GenericMethod *_create_f_operator_eq__2448 ()
{
  return new qt_gsi::GenericMethod ("assign", "@brief Method QTextOption &QTextOption::operator=(const QTextOption &o)\n", false, &_init_f_operator_eq__2448, &_call_f_operator_eq__2448);
}

// void QTextOption::setAlignment(QFlags<Qt::AlignmentFlag> alignment)


static void _init_f_setAlignment_2750 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("alignment");
  decl->add_arg<const qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type & > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setAlignment_2750 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type & arg1 = args.read<const qt_gsi::Converter<QFlags<Qt::AlignmentFlag> >::target_type & > ();
  ((QTextOption *)cls)->setAlignment (qt_gsi::QtToCppAdaptor<QFlags<Qt::AlignmentFlag> >(arg1).cref());
}

static qt_gsi::GenericMethod *_create_f_setAlignment_2750 ()
{
  return new qt_gsi::GenericMethod ("setAlignment|alignment=", "@brief Method void QTextOption::setAlignment(QFlags<Qt::AlignmentFlag> alignment)\n", false, &_init_f_setAlignment_2750, &_call_f_setAlignment_2750);
}

// void QTextOption::setFlags(QFlags<QTextOption::Flag> flags)


static void _init_f_setFlags_2761 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("flags");
  decl->add_arg<const qt_gsi::Converter<QFlags<QTextOption::Flag> >::target_type & > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setFlags_2761 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QFlags<QTextOption::Flag> >::target_type & arg1 = args.read<const qt_gsi::Converter<QFlags<QTextOption::Flag> >::target_type & > ();
  ((QTextOption *)cls)->setFlags (qt_gsi::QtToCppAdaptor<QFlags<QTextOption::Flag> >(arg1).cref());
}

static qt_gsi::GenericMethod *_create_f_setFlags_2761 ()
{
  return new qt_gsi::GenericMethod ("setFlags|flags=", "@brief Method void QTextOption::setFlags(QFlags<QTextOption::Flag> flags)\n", false, &_init_f_setFlags_2761, &_call_f_setFlags_2761);
}

// void QTextOption::setTabArray(QList<double> tabStops)


static void _init_f_setTabArray_1686 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("tabStops");
  decl->add_arg<const qt_gsi::Converter<QList<double> >::target_type & > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setTabArray_1686 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QList<double> >::target_type & arg1 = args.read<const qt_gsi::Converter<QList<double> >::target_type & > ();
  ((QTextOption *)cls)->setTabArray (qt_gsi::QtToCppAdaptor<QList<double> >(arg1).cref());
}

static qt_gsi::GenericMethod *_create_f_setTabArray_1686 ()
{
  return new qt_gsi::GenericMethod ("setTabArray|tabArray=", "@brief Method void QTextOption::setTabArray(QList<double> tabStops)\n", false, &_init_f_setTabArray_1686, &_call_f_setTabArray_1686);
}

// void QTextOption::setTabStop(double tabStop)


static void _init_f_setTabStop_1071 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("tabStop");
  decl->add_arg<double > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setTabStop_1071 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  double arg1 = args.read<double > ();
  ((QTextOption *)cls)->setTabStop (arg1);
}

static qt_gsi::GenericMethod *_create_f_setTabStop_1071 ()
{
  return new qt_gsi::GenericMethod ("setTabStop|tabStop=", "@brief Method void QTextOption::setTabStop(double tabStop)\n", false, &_init_f_setTabStop_1071, &_call_f_setTabStop_1071);
}

// void QTextOption::setTabs(QList<QTextOption::Tab> tabStops)


static void _init_f_setTabs_2581 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("tabStops");
  decl->add_arg<const qt_gsi::Converter<QList<QTextOption::Tab> >::target_type & > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setTabs_2581 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QList<QTextOption::Tab> >::target_type & arg1 = args.read<const qt_gsi::Converter<QList<QTextOption::Tab> >::target_type & > ();
  ((QTextOption *)cls)->setTabs (qt_gsi::QtToCppAdaptor<QList<QTextOption::Tab> >(arg1).cref());
}

static qt_gsi::GenericMethod *_create_f_setTabs_2581 ()
{
  return new qt_gsi::GenericMethod ("setTabs|tabs=", "@brief Method void QTextOption::setTabs(QList<QTextOption::Tab> tabStops)\n", false, &_init_f_setTabs_2581, &_call_f_setTabs_2581);
}

// void QTextOption::setTextDirection(Qt::LayoutDirection aDirection)


static void _init_f_setTextDirection_2316 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("aDirection");
  decl->add_arg<const qt_gsi::Converter<Qt::LayoutDirection>::target_type & > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setTextDirection_2316 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<Qt::LayoutDirection>::target_type & arg1 = args.read<const qt_gsi::Converter<Qt::LayoutDirection>::target_type & > ();
  ((QTextOption *)cls)->setTextDirection (qt_gsi::QtToCppAdaptor<Qt::LayoutDirection>(arg1).cref());
}

static qt_gsi::GenericMethod *_create_f_setTextDirection_2316 ()
{
  return new qt_gsi::GenericMethod ("setTextDirection|textDirection=", "@brief Method void QTextOption::setTextDirection(Qt::LayoutDirection aDirection)\n", false, &_init_f_setTextDirection_2316, &_call_f_setTextDirection_2316);
}

// void QTextOption::setUseDesignMetrics(bool b)


static void _init_f_setUseDesignMetrics_864 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("b");
  decl->add_arg<bool > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setUseDesignMetrics_864 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  bool arg1 = args.read<bool > ();
  ((QTextOption *)cls)->setUseDesignMetrics (arg1);
}

static qt_gsi::GenericMethod *_create_f_setUseDesignMetrics_864 ()
{
  return new qt_gsi::GenericMethod ("setUseDesignMetrics|useDesignMetrics=", "@brief Method void QTextOption::setUseDesignMetrics(bool b)\n", false, &_init_f_setUseDesignMetrics_864, &_call_f_setUseDesignMetrics_864);
}

// void QTextOption::setWrapMode(QTextOption::WrapMode wrap)


static void _init_f_setWrapMode_2486 (qt_gsi::GenericMethod *decl)
{
  static gsi::ArgSpecBase argspec_0 ("wrap");
  decl->add_arg<const qt_gsi::Converter<QTextOption::WrapMode>::target_type & > (argspec_0);
  decl->set_return<void > ();
}

static void _call_f_setWrapMode_2486 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  const qt_gsi::Converter<QTextOption::WrapMode>::target_type & arg1 = args.read<const qt_gsi::Converter<QTextOption::WrapMode>::target_type & > ();
  ((QTextOption *)cls)->setWrapMode (qt_gsi::QtToCppAdaptor<QTextOption::WrapMode>(arg1).cref());
}

static qt_gsi::GenericMethod *_create_f_setWrapMode_2486 ()
{
  return new qt_gsi::GenericMethod ("setWrapMode|wrapMode=", "@brief Method void QTextOption::setWrapMode(QTextOption::WrapMode wrap)\n", false, &_init_f_setWrapMode_2486, &_call_f_setWrapMode_2486);
}

// QList<double> QTextOption::tabArray()


static void _init_f_tabArray_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QList<double> >::target_type > ();
}

static void _call_f_tabArray_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QList<double> >::target_type > ((qt_gsi::Converter<QList<double> >::target_type)qt_gsi::CppToQtAdaptor<QList<double> >(((QTextOption *)cls)->tabArray ()));
}

static qt_gsi::GenericMethod *_create_f_tabArray_c0 ()
{
  return new qt_gsi::GenericMethod (":tabArray", "@brief Method QList<double> QTextOption::tabArray()\n", true, &_init_f_tabArray_c0, &_call_f_tabArray_c0);
}

// double QTextOption::tabStop()


static void _init_f_tabStop_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<double > ();
}

static void _call_f_tabStop_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<double > ((double)((QTextOption *)cls)->tabStop ());
}

static qt_gsi::GenericMethod *_create_f_tabStop_c0 ()
{
  return new qt_gsi::GenericMethod (":tabStop", "@brief Method double QTextOption::tabStop()\n", true, &_init_f_tabStop_c0, &_call_f_tabStop_c0);
}

// QList<QTextOption::Tab> QTextOption::tabs()


static void _init_f_tabs_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QList<QTextOption::Tab> >::target_type > ();
}

static void _call_f_tabs_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QList<QTextOption::Tab> >::target_type > ((qt_gsi::Converter<QList<QTextOption::Tab> >::target_type)qt_gsi::CppToQtAdaptor<QList<QTextOption::Tab> >(((QTextOption *)cls)->tabs ()));
}

static qt_gsi::GenericMethod *_create_f_tabs_c0 ()
{
  return new qt_gsi::GenericMethod (":tabs", "@brief Method QList<QTextOption::Tab> QTextOption::tabs()\n", true, &_init_f_tabs_c0, &_call_f_tabs_c0);
}

// Qt::LayoutDirection QTextOption::textDirection()


static void _init_f_textDirection_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<Qt::LayoutDirection>::target_type > ();
}

static void _call_f_textDirection_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<Qt::LayoutDirection>::target_type > ((qt_gsi::Converter<Qt::LayoutDirection>::target_type)qt_gsi::CppToQtAdaptor<Qt::LayoutDirection>(((QTextOption *)cls)->textDirection ()));
}

static qt_gsi::GenericMethod *_create_f_textDirection_c0 ()
{
  return new qt_gsi::GenericMethod (":textDirection", "@brief Method Qt::LayoutDirection QTextOption::textDirection()\n", true, &_init_f_textDirection_c0, &_call_f_textDirection_c0);
}

// bool QTextOption::useDesignMetrics()


static void _init_f_useDesignMetrics_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<bool > ();
}

static void _call_f_useDesignMetrics_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<bool > ((bool)((QTextOption *)cls)->useDesignMetrics ());
}

static qt_gsi::GenericMethod *_create_f_useDesignMetrics_c0 ()
{
  return new qt_gsi::GenericMethod (":useDesignMetrics", "@brief Method bool QTextOption::useDesignMetrics()\n", true, &_init_f_useDesignMetrics_c0, &_call_f_useDesignMetrics_c0);
}

// QTextOption::WrapMode QTextOption::wrapMode()


static void _init_f_wrapMode_c0 (qt_gsi::GenericMethod *decl)
{
  decl->set_return<qt_gsi::Converter<QTextOption::WrapMode>::target_type > ();
}

static void _call_f_wrapMode_c0 (const qt_gsi::GenericMethod *decl, void *cls, gsi::SerialArgs &args, gsi::SerialArgs &ret) 
{
  ret.write<qt_gsi::Converter<QTextOption::WrapMode>::target_type > ((qt_gsi::Converter<QTextOption::WrapMode>::target_type)qt_gsi::CppToQtAdaptor<QTextOption::WrapMode>(((QTextOption *)cls)->wrapMode ()));
}

static qt_gsi::GenericMethod *_create_f_wrapMode_c0 ()
{
  return new qt_gsi::GenericMethod (":wrapMode", "@brief Method QTextOption::WrapMode QTextOption::wrapMode()\n", true, &_init_f_wrapMode_c0, &_call_f_wrapMode_c0);
}


namespace gsi
{
gsi::Class<QTextOption> decl_QTextOption ("QTextOption",
  gsi::Methods(_create_ctor_QTextOption_0 ()) +
  gsi::Methods(_create_ctor_QTextOption_2750 ()) +
  gsi::Methods(_create_ctor_QTextOption_2448 ()) +
  gsi::Methods(_create_f_alignment_c0 ()) +
  gsi::Methods(_create_f_flags_c0 ()) +
  gsi::Methods(_create_f_operator_eq__2448 ()) +
  gsi::Methods(_create_f_setAlignment_2750 ()) +
  gsi::Methods(_create_f_setFlags_2761 ()) +
  gsi::Methods(_create_f_setTabArray_1686 ()) +
  gsi::Methods(_create_f_setTabStop_1071 ()) +
  gsi::Methods(_create_f_setTabs_2581 ()) +
  gsi::Methods(_create_f_setTextDirection_2316 ()) +
  gsi::Methods(_create_f_setUseDesignMetrics_864 ()) +
  gsi::Methods(_create_f_setWrapMode_2486 ()) +
  gsi::Methods(_create_f_tabArray_c0 ()) +
  gsi::Methods(_create_f_tabStop_c0 ()) +
  gsi::Methods(_create_f_tabs_c0 ()) +
  gsi::Methods(_create_f_textDirection_c0 ()) +
  gsi::Methods(_create_f_useDesignMetrics_c0 ()) +
  gsi::Methods(_create_f_wrapMode_c0 ()),
  "@qt\n@brief Binding of QTextOption");

}


//  Implementation of the enum wrapper class for QTextOption::Flag
namespace qt_gsi
{

static QTextOption_Flag_Enum *c_1_QTextOption_Flag_Enum () { return new QTextOption_Flag_Enum (QTextOption::ShowTabsAndSpaces); }
static QTextOption_Flag_Enum *c_2_QTextOption_Flag_Enum () { return new QTextOption_Flag_Enum (QTextOption::ShowLineAndParagraphSeparators); }
static QTextOption_Flag_Enum *c_3_QTextOption_Flag_Enum () { return new QTextOption_Flag_Enum (QTextOption::AddSpaceForLineAndParagraphSeparators); }
static QTextOption_Flag_Enum *c_4_QTextOption_Flag_Enum () { return new QTextOption_Flag_Enum (QTextOption::SuppressColors); }
static QTextOption_Flag_Enum *c_5_QTextOption_Flag_Enum () { return new QTextOption_Flag_Enum (QTextOption::IncludeTrailingSpaces); }

static gsi::Methods mkdefs_QTextOption_Flag () {
  return
    gsi::constant ("ShowTabsAndSpaces", &qt_gsi::c_1_QTextOption_Flag_Enum, "@brief Enum constant QTextOption::ShowTabsAndSpaces") +
    gsi::constant ("ShowLineAndParagraphSeparators", &qt_gsi::c_2_QTextOption_Flag_Enum, "@brief Enum constant QTextOption::ShowLineAndParagraphSeparators") +
    gsi::constant ("AddSpaceForLineAndParagraphSeparators", &qt_gsi::c_3_QTextOption_Flag_Enum, "@brief Enum constant QTextOption::AddSpaceForLineAndParagraphSeparators") +
    gsi::constant ("SuppressColors", &qt_gsi::c_4_QTextOption_Flag_Enum, "@brief Enum constant QTextOption::SuppressColors") +
    gsi::constant ("IncludeTrailingSpaces", &qt_gsi::c_5_QTextOption_Flag_Enum, "@brief Enum constant QTextOption::IncludeTrailingSpaces");
}

static std::string to_s_QTextOption_Flag_Enum (const QTextOption_Flag_Enum *e)
{
  if (e->value () == QTextOption::ShowTabsAndSpaces) { return tl::sprintf ("ShowTabsAndSpaces (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::ShowLineAndParagraphSeparators) { return tl::sprintf ("ShowLineAndParagraphSeparators (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::AddSpaceForLineAndParagraphSeparators) { return tl::sprintf ("AddSpaceForLineAndParagraphSeparators (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::SuppressColors) { return tl::sprintf ("SuppressColors (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::IncludeTrailingSpaces) { return tl::sprintf ("IncludeTrailingSpaces (%u)", (unsigned int) e->value ()); }
  return std::string ("(not a valid enum evalue)");
}

static unsigned int to_i_QTextOption_Flag_Enum (const QTextOption_Flag_Enum *e)
{
  return (unsigned int) e->value ();
}

static QTextOption_Flag_Enum *from_i_QTextOption_Flag_Enum (unsigned int i)
{
  return new QTextOption_Flag_Enum ((QTextOption::Flag) i);
}

static bool equalQTextOption_Flag_Enum (const QTextOption_Flag_Enum *e, QTextOption_Flag_Enum d)
{
  return e->value () == d.value ();
}

static bool equal2QTextOption_Flag_Enum (const QTextOption_Flag_Enum *e, unsigned int i)
{
  return (unsigned int) e->value () == i;
}

static QTextOption_Flag_Enums oropQTextOption_Flag_Enums (const QTextOption_Flag_Enums *e, const QTextOption_Flag_Enums &d)
{
  return e->flags () | d.flags ();
}

static QTextOption_Flag_Enums andopQTextOption_Flag_Enums (const QTextOption_Flag_Enums *e, const QTextOption_Flag_Enums &d)
{
  return e->flags () & d.flags ();
}

static QTextOption_Flag_Enums xoropQTextOption_Flag_Enums (const QTextOption_Flag_Enums *e, const QTextOption_Flag_Enums &d)
{
  return e->flags () ^ d.flags ();
}

static std::string to_s_QTextOption_Flag_Enums (const QTextOption_Flag_Enums *e)
{
  std::string l;
  if (e->testFlag (QTextOption::ShowTabsAndSpaces)) { if (!l.empty ()) l += "|"; l += "ShowTabsAndSpaces"; }
  if (e->testFlag (QTextOption::ShowLineAndParagraphSeparators)) { if (!l.empty ()) l += "|"; l += "ShowLineAndParagraphSeparators"; }
  if (e->testFlag (QTextOption::AddSpaceForLineAndParagraphSeparators)) { if (!l.empty ()) l += "|"; l += "AddSpaceForLineAndParagraphSeparators"; }
  if (e->testFlag (QTextOption::SuppressColors)) { if (!l.empty ()) l += "|"; l += "SuppressColors"; }
  if (e->testFlag (QTextOption::IncludeTrailingSpaces)) { if (!l.empty ()) l += "|"; l += "IncludeTrailingSpaces"; }
  return tl::sprintf ("%u (%s)", (unsigned int) (e->flags ()), l);
}

static int to_i_QTextOption_Flag_Enums (const QTextOption_Flag_Enums *e)
{
  return int (e->flags ());
}

static bool testFlag_QTextOption_Flag_Enums (const QTextOption_Flag_Enums *e, const QTextOption_Flag_Enum &d)
{
  return e->flags ().testFlag (d.value ());
}

}

namespace gsi
{

//  Declarations for QFlags<enum> wrapper class
gsi::Class<qt_gsi::QTextOption_Flag_Enums> decl_QTextOption_Flag_Enums ("QTextOption_QFlags_Flag",
  gsi::method_ext ("|", &qt_gsi::oropQTextOption_Flag_Enums, gsi::arg ("other"), "@brief 'or' operator between two flag sets") +
  gsi::method_ext ("&", &qt_gsi::andopQTextOption_Flag_Enums, gsi::arg ("other"), "@brief 'and' operator between two flag sets") +
  gsi::method_ext ("^", &qt_gsi::xoropQTextOption_Flag_Enums, gsi::arg ("other"), "@brief 'xor' operator between two flag sets") +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QTextOption_Flag_Enums, "@brief Converts the flag set to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QTextOption_Flag_Enums, "@brief Returns the integer value encoding the flag set") +
  gsi::method_ext ("testFlag", &qt_gsi::testFlag_QTextOption_Flag_Enums, gsi::arg ("flag"), "@brief Tests whether the flag is contained in the flag set"),
  "@qt\n@brief This class represents the QFlags<QTextOption::Flag> flag set");

//  Declarations for enum wrapper class
gsi::Class<qt_gsi::QTextOption_Flag_Enum> decl_QTextOption_Flag_Enum (decl_QTextOption_Flag_Enums, "QTextOption_Flag",
  qt_gsi::mkdefs_QTextOption_Flag () +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QTextOption_Flag_Enum, "@brief Converts the enum class to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QTextOption_Flag_Enum, "@brief Converts the enum class to an integer") +
  gsi::method_ext ("==", &qt_gsi::equalQTextOption_Flag_Enum, gsi::arg ("other"), "@brief Compares the enum class against an enum of it's own type") +
  gsi::method_ext ("==", &qt_gsi::equal2QTextOption_Flag_Enum, gsi::arg ("other"), "@brief Compares the enum class against an integer") +
  gsi::constructor ("new", &qt_gsi::from_i_QTextOption_Flag_Enum, gsi::arg ("value"), "@brief Creates the enum object from an integer"),
  "@qt\n@brief This class represents the QTextOption::Flag enum");

//  Inject the declarations into the parent
static gsi::ClassExt<QTextOption> inject_QTextOption_Flag_Enum_in_parent (qt_gsi::mkdefs_QTextOption_Flag ());
static gsi::ClassExt<QTextOption> decl_QTextOption_Flag_Enum_as_child (decl_QTextOption_Flag_Enum, "Flag");

}


//  Implementation of the enum wrapper class for QTextOption::WrapMode
namespace qt_gsi
{

static QTextOption_WrapMode_Enum *c_1_QTextOption_WrapMode_Enum () { return new QTextOption_WrapMode_Enum (QTextOption::NoWrap); }
static QTextOption_WrapMode_Enum *c_2_QTextOption_WrapMode_Enum () { return new QTextOption_WrapMode_Enum (QTextOption::WordWrap); }
static QTextOption_WrapMode_Enum *c_3_QTextOption_WrapMode_Enum () { return new QTextOption_WrapMode_Enum (QTextOption::ManualWrap); }
static QTextOption_WrapMode_Enum *c_4_QTextOption_WrapMode_Enum () { return new QTextOption_WrapMode_Enum (QTextOption::WrapAnywhere); }
static QTextOption_WrapMode_Enum *c_5_QTextOption_WrapMode_Enum () { return new QTextOption_WrapMode_Enum (QTextOption::WrapAtWordBoundaryOrAnywhere); }

static gsi::Methods mkdefs_QTextOption_WrapMode () {
  return
    gsi::constant ("NoWrap", &qt_gsi::c_1_QTextOption_WrapMode_Enum, "@brief Enum constant QTextOption::NoWrap") +
    gsi::constant ("WordWrap", &qt_gsi::c_2_QTextOption_WrapMode_Enum, "@brief Enum constant QTextOption::WordWrap") +
    gsi::constant ("ManualWrap", &qt_gsi::c_3_QTextOption_WrapMode_Enum, "@brief Enum constant QTextOption::ManualWrap") +
    gsi::constant ("WrapAnywhere", &qt_gsi::c_4_QTextOption_WrapMode_Enum, "@brief Enum constant QTextOption::WrapAnywhere") +
    gsi::constant ("WrapAtWordBoundaryOrAnywhere", &qt_gsi::c_5_QTextOption_WrapMode_Enum, "@brief Enum constant QTextOption::WrapAtWordBoundaryOrAnywhere");
}

static std::string to_s_QTextOption_WrapMode_Enum (const QTextOption_WrapMode_Enum *e)
{
  if (e->value () == QTextOption::NoWrap) { return tl::sprintf ("NoWrap (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::WordWrap) { return tl::sprintf ("WordWrap (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::ManualWrap) { return tl::sprintf ("ManualWrap (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::WrapAnywhere) { return tl::sprintf ("WrapAnywhere (%u)", (unsigned int) e->value ()); }
  if (e->value () == QTextOption::WrapAtWordBoundaryOrAnywhere) { return tl::sprintf ("WrapAtWordBoundaryOrAnywhere (%u)", (unsigned int) e->value ()); }
  return std::string ("(not a valid enum evalue)");
}

static unsigned int to_i_QTextOption_WrapMode_Enum (const QTextOption_WrapMode_Enum *e)
{
  return (unsigned int) e->value ();
}

static QTextOption_WrapMode_Enum *from_i_QTextOption_WrapMode_Enum (unsigned int i)
{
  return new QTextOption_WrapMode_Enum ((QTextOption::WrapMode) i);
}

static bool equalQTextOption_WrapMode_Enum (const QTextOption_WrapMode_Enum *e, QTextOption_WrapMode_Enum d)
{
  return e->value () == d.value ();
}

static bool equal2QTextOption_WrapMode_Enum (const QTextOption_WrapMode_Enum *e, unsigned int i)
{
  return (unsigned int) e->value () == i;
}

static QTextOption_WrapMode_Enums oropQTextOption_WrapMode_Enums (const QTextOption_WrapMode_Enums *e, const QTextOption_WrapMode_Enums &d)
{
  return e->flags () | d.flags ();
}

static QTextOption_WrapMode_Enums andopQTextOption_WrapMode_Enums (const QTextOption_WrapMode_Enums *e, const QTextOption_WrapMode_Enums &d)
{
  return e->flags () & d.flags ();
}

static QTextOption_WrapMode_Enums xoropQTextOption_WrapMode_Enums (const QTextOption_WrapMode_Enums *e, const QTextOption_WrapMode_Enums &d)
{
  return e->flags () ^ d.flags ();
}

static std::string to_s_QTextOption_WrapMode_Enums (const QTextOption_WrapMode_Enums *e)
{
  std::string l;
  if (e->testFlag (QTextOption::NoWrap)) { if (!l.empty ()) l += "|"; l += "NoWrap"; }
  if (e->testFlag (QTextOption::WordWrap)) { if (!l.empty ()) l += "|"; l += "WordWrap"; }
  if (e->testFlag (QTextOption::ManualWrap)) { if (!l.empty ()) l += "|"; l += "ManualWrap"; }
  if (e->testFlag (QTextOption::WrapAnywhere)) { if (!l.empty ()) l += "|"; l += "WrapAnywhere"; }
  if (e->testFlag (QTextOption::WrapAtWordBoundaryOrAnywhere)) { if (!l.empty ()) l += "|"; l += "WrapAtWordBoundaryOrAnywhere"; }
  return tl::sprintf ("%u (%s)", (unsigned int) (e->flags ()), l);
}

static int to_i_QTextOption_WrapMode_Enums (const QTextOption_WrapMode_Enums *e)
{
  return int (e->flags ());
}

static bool testFlag_QTextOption_WrapMode_Enums (const QTextOption_WrapMode_Enums *e, const QTextOption_WrapMode_Enum &d)
{
  return e->flags ().testFlag (d.value ());
}

}

namespace gsi
{

//  Declarations for QFlags<enum> wrapper class
gsi::Class<qt_gsi::QTextOption_WrapMode_Enums> decl_QTextOption_WrapMode_Enums ("QTextOption_QFlags_WrapMode",
  gsi::method_ext ("|", &qt_gsi::oropQTextOption_WrapMode_Enums, gsi::arg ("other"), "@brief 'or' operator between two flag sets") +
  gsi::method_ext ("&", &qt_gsi::andopQTextOption_WrapMode_Enums, gsi::arg ("other"), "@brief 'and' operator between two flag sets") +
  gsi::method_ext ("^", &qt_gsi::xoropQTextOption_WrapMode_Enums, gsi::arg ("other"), "@brief 'xor' operator between two flag sets") +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QTextOption_WrapMode_Enums, "@brief Converts the flag set to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QTextOption_WrapMode_Enums, "@brief Returns the integer value encoding the flag set") +
  gsi::method_ext ("testFlag", &qt_gsi::testFlag_QTextOption_WrapMode_Enums, gsi::arg ("flag"), "@brief Tests whether the flag is contained in the flag set"),
  "@qt\n@brief This class represents the QFlags<QTextOption::WrapMode> flag set");

//  Declarations for enum wrapper class
gsi::Class<qt_gsi::QTextOption_WrapMode_Enum> decl_QTextOption_WrapMode_Enum (decl_QTextOption_WrapMode_Enums, "QTextOption_WrapMode",
  qt_gsi::mkdefs_QTextOption_WrapMode () +
  gsi::method_ext ("to_s|inspect", &qt_gsi::to_s_QTextOption_WrapMode_Enum, "@brief Converts the enum class to a string") +
  gsi::method_ext ("to_i", &qt_gsi::to_i_QTextOption_WrapMode_Enum, "@brief Converts the enum class to an integer") +
  gsi::method_ext ("==", &qt_gsi::equalQTextOption_WrapMode_Enum, gsi::arg ("other"), "@brief Compares the enum class against an enum of it's own type") +
  gsi::method_ext ("==", &qt_gsi::equal2QTextOption_WrapMode_Enum, gsi::arg ("other"), "@brief Compares the enum class against an integer") +
  gsi::constructor ("new", &qt_gsi::from_i_QTextOption_WrapMode_Enum, gsi::arg ("value"), "@brief Creates the enum object from an integer"),
  "@qt\n@brief This class represents the QTextOption::WrapMode enum");

//  Inject the declarations into the parent
static gsi::ClassExt<QTextOption> inject_QTextOption_WrapMode_Enum_in_parent (qt_gsi::mkdefs_QTextOption_WrapMode ());
static gsi::ClassExt<QTextOption> decl_QTextOption_WrapMode_Enum_as_child (decl_QTextOption_WrapMode_Enum, "WrapMode");

}

